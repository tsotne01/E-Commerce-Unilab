import {
  appendErrors,
  get,
  set
} from "./chunk-ZYGSGDEV.js";
import "./chunk-CBG3MKAY.js";
import "./chunk-EQCVQC35.js";

// node_modules/@hookform/resolvers/dist/resolvers.mjs
var r = (t, r2, o2) => {
  if (t && "reportValidity" in t) {
    const s2 = get(o2, r2);
    t.setCustomValidity(s2 && s2.message || ""), t.reportValidity();
  }
};
var o = (e, t) => {
  for (const o2 in t.fields) {
    const s2 = t.fields[o2];
    s2 && s2.ref && "reportValidity" in s2.ref ? r(s2.ref, o2, e) : s2 && s2.refs && s2.refs.forEach((t2) => r(t2, o2, e));
  }
};
var s = (r2, s2) => {
  s2.shouldUseNativeValidation && o(r2, s2);
  const n2 = {};
  for (const o2 in r2) {
    const f = get(s2.fields, o2), c = Object.assign(r2[o2] || {}, { ref: f && f.ref });
    if (i(s2.names || Object.keys(r2), o2)) {
      const r3 = Object.assign({}, get(n2, o2));
      set(r3, "root", c), set(n2, o2, r3);
    } else set(n2, o2, c);
  }
  return n2;
};
var i = (e, t) => {
  const r2 = n(t);
  return e.some((e2) => n(e2).match(`^${r2}\\.\\d+`));
};
function n(e) {
  return e.replace(/\]|\[/g, "");
}

// node_modules/@hookform/resolvers/zod/src/zod.ts
var isZodError = (error) => Array.isArray(error == null ? void 0 : error.errors);
function parseErrorSchema(zodErrors, validateAllFieldCriteria) {
  const errors = {};
  for (; zodErrors.length; ) {
    const error = zodErrors[0];
    const { code, message, path } = error;
    const _path = path.join(".");
    if (!errors[_path]) {
      if ("unionErrors" in error) {
        const unionError = error.unionErrors[0].errors[0];
        errors[_path] = {
          message: unionError.message,
          type: unionError.code
        };
      } else {
        errors[_path] = { message, type: code };
      }
    }
    if ("unionErrors" in error) {
      error.unionErrors.forEach(
        (unionError) => unionError.errors.forEach((e) => zodErrors.push(e))
      );
    }
    if (validateAllFieldCriteria) {
      const types = errors[_path].types;
      const messages = types && types[error.code];
      errors[_path] = appendErrors(
        _path,
        validateAllFieldCriteria,
        errors,
        code,
        messages ? [].concat(messages, error.message) : error.message
      );
    }
    zodErrors.shift();
  }
  return errors;
}
function zodResolver(schema, schemaOptions, resolverOptions = {}) {
  return async (values, _, options) => {
    try {
      const data = await schema[resolverOptions.mode === "sync" ? "parse" : "parseAsync"](values, schemaOptions);
      options.shouldUseNativeValidation && o({}, options);
      return {
        errors: {},
        values: resolverOptions.raw ? Object.assign({}, values) : data
      };
    } catch (error) {
      if (isZodError(error)) {
        return {
          values: {},
          errors: s(
            parseErrorSchema(
              error.errors,
              !options.shouldUseNativeValidation && options.criteriaMode === "all"
            ),
            options
          )
        };
      }
      throw error;
    }
  };
}
export {
  zodResolver
};
//# sourceMappingURL=@hookform_resolvers_zod_src_zod__js.js.map
