{
  "version": 3,
  "sources": ["../../@hookform/resolvers/src/validateFieldsNatively.ts", "../../@hookform/resolvers/src/toNestErrors.ts", "../../@hookform/resolvers/zod/src/zod.ts"],
  "sourcesContent": ["import {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Ref,\n  ResolverOptions,\n  get,\n} from 'react-hook-form';\n\nconst setCustomValidity = (\n  ref: Ref,\n  fieldPath: string,\n  errors: FieldErrors,\n) => {\n  if (ref && 'reportValidity' in ref) {\n    const error = get(errors, fieldPath) as FieldError | undefined;\n    ref.setCustomValidity((error && error.message) || '');\n\n    ref.reportValidity();\n  }\n};\n\n// Native validation (web only)\nexport const validateFieldsNatively = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): void => {\n  for (const fieldPath in options.fields) {\n    const field = options.fields[fieldPath];\n    if (field && field.ref && 'reportValidity' in field.ref) {\n      setCustomValidity(field.ref, fieldPath, errors);\n    } else if (field && field.refs) {\n      field.refs.forEach((ref: HTMLInputElement) =>\n        setCustomValidity(ref, fieldPath, errors),\n      );\n    }\n  }\n};\n", "import {\n  Field,\n  FieldErrors,\n  FieldValues,\n  InternalFieldName,\n  ResolverOptions,\n  get,\n  set,\n} from 'react-hook-form';\nimport { validateFieldsNatively } from './validateFieldsNatively';\n\nexport const toNestErrors = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): FieldErrors<TFieldValues> => {\n  options.shouldUseNativeValidation && validateFieldsNatively(errors, options);\n\n  const fieldErrors = {} as FieldErrors<TFieldValues>;\n  for (const path in errors) {\n    const field = get(options.fields, path) as Field['_f'] | undefined;\n    const error = Object.assign(errors[path] || {}, {\n      ref: field && field.ref,\n    });\n\n    if (isNameInFieldArray(options.names || Object.keys(errors), path)) {\n      const fieldArrayErrors = Object.assign({}, get(fieldErrors, path));\n\n      set(fieldArrayErrors, 'root', error);\n      set(fieldErrors, path, fieldArrayErrors);\n    } else {\n      set(fieldErrors, path, error);\n    }\n  }\n\n  return fieldErrors;\n};\n\nconst isNameInFieldArray = (\n  names: InternalFieldName[],\n  name: InternalFieldName,\n) => {\n  const path = escapeBrackets(name);\n  return names.some((n) => escapeBrackets(n).match(`^${path}\\\\.\\\\d+`));\n};\n\n/**\n * Escapes special characters in a string to be used in a regex pattern.\n * it removes the brackets from the string to match the `set` method.\n *\n * @param input - The input string to escape.\n * @returns The escaped string.\n */\nfunction escapeBrackets(input: string): string {\n  return input.replace(/\\]|\\[/g, '');\n}\n", "import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  appendErrors,\n} from 'react-hook-form';\nimport { ZodError, z } from 'zod';\n\nconst isZodError = (error: any): error is ZodError =>\n  Array.isArray(error?.errors);\n\nfunction parseErrorSchema(\n  zodErrors: z.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: z.ZodSchema<Output, any, Input>,\n  schemaOptions?: Partial<z.ParseParams>,\n  resolverOptions?: {\n    mode?: 'async' | 'sync';\n    raw?: false;\n  },\n): Resolver<Input, Context, Output>;\n\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: z.ZodSchema<Output, any, Input>,\n  schemaOptions: Partial<z.ParseParams> | undefined,\n  resolverOptions: {\n    mode?: 'async' | 'sync';\n    raw: true;\n  },\n): Resolver<Input, Context, Input>;\n\n/**\n * Creates a resolver function for react-hook-form that validates form data using a Zod schema\n * @param {z.ZodSchema<Input>} schema - The Zod schema used to validate the form data\n * @param {Partial<z.ParseParams>} [schemaOptions] - Optional configuration options for Zod parsing\n * @param {Object} [resolverOptions] - Optional resolver-specific configuration\n * @param {('async'|'sync')} [resolverOptions.mode='async'] - Validation mode. Use 'sync' for synchronous validation\n * @param {boolean} [resolverOptions.raw=false] - If true, returns the raw form values instead of the parsed data\n * @returns {Resolver<z.output<typeof schema>>} A resolver function compatible with react-hook-form\n * @throws {Error} Throws if validation fails with a non-Zod error\n * @example\n * const schema = z.object({\n *   name: z.string().min(2),\n *   age: z.number().min(18)\n * });\n *\n * useForm({\n *   resolver: zodResolver(schema)\n * });\n */\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: z.ZodSchema<Output, any, Input>,\n  schemaOptions?: Partial<z.ParseParams>,\n  resolverOptions: {\n    mode?: 'async' | 'sync';\n    raw?: boolean;\n  } = {},\n): Resolver<Input, Context, Output | Input> {\n  return async (values: Input, _, options) => {\n    try {\n      const data = await schema[\n        resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n      ](values, schemaOptions);\n\n      options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n      return {\n        errors: {} as FieldErrors,\n        values: resolverOptions.raw ? Object.assign({}, values) : data,\n      } satisfies ResolverSuccess<Output | Input>;\n    } catch (error) {\n      if (isZodError(error)) {\n        return {\n          values: {},\n          errors: toNestErrors(\n            parseErrorSchema(\n              error.errors,\n              !options.shouldUseNativeValidation &&\n                options.criteriaMode === 'all',\n            ),\n            options,\n          ),\n        } satisfies ResolverError<Input>;\n      }\n\n      throw error;\n    }\n  };\n}\n"],
  "mappings": ";;;;;;;;;AASA,IAAMA,IAAoBA,CACxBC,GACAC,IACAC,OAAAA;AAEA,MAAIF,KAAO,oBAAoBA,GAAK;AAClC,UAAMG,KAAQC,IAAIF,IAAQD,EAAAA;AAC1BD,MAAID,kBAAmBI,MAASA,GAAME,WAAY,EAAA,GAElDL,EAAIM,eAAAA;EACN;AAAA;AAVF,IAcaC,IAAyBA,CACpCL,GACAM,MAAAA;AAEA,aAAWP,MAAaO,EAAQC,QAAQ;AACtC,UAAMC,KAAQF,EAAQC,OAAOR,EAAAA;AACzBS,IAAAA,MAASA,GAAMV,OAAO,oBAAoBU,GAAMV,MAClDD,EAAkBW,GAAMV,KAAKC,IAAWC,CAAAA,IAC/BQ,MAASA,GAAMC,QACxBD,GAAMC,KAAKC,QAASZ,CAAAA,OAClBD,EAAkBC,IAAKC,IAAWC,CAAAA,CAAAA;EAGxC;AAAA;AA3BF,ICEaW,IAAeA,CAC1BX,IACAM,OAAAA;AAEAA,EAAAA,GAAQM,6BAA6BP,EAAuBL,IAAQM,EAAAA;AAEpE,QAAMO,KAAc,CAAA;AACpB,aAAWC,MAAQd,IAAQ;AACzB,UAAMQ,IAAQN,IAAII,GAAQC,QAAQO,EAAAA,GAC5Bb,IAAQc,OAAOC,OAAOhB,GAAOc,EAAAA,KAAS,CAAA,GAAI,EAC9ChB,KAAKU,KAASA,EAAMV,IAAAA,CAAAA;AAGtB,QAAImB,EAAmBX,GAAQY,SAASH,OAAOI,KAAKnB,EAAAA,GAASc,EAAAA,GAAO;AAClE,YAAMM,KAAmBL,OAAOC,OAAO,CAAA,GAAId,IAAIW,IAAaC,EAAAA,CAAAA;AAE5DO,UAAID,IAAkB,QAAQnB,CAAAA,GAC9BoB,IAAIR,IAAaC,IAAMM,EAAAA;IACzB,MACEC,KAAIR,IAAaC,IAAMb,CAAAA;EAE3B;AAEA,SAAOY;AAAAA;ADzBT,IC4BMI,IAAqBA,CACzBC,GACAI,MAAAA;AAEA,QAAMR,KAAOS,EAAeD,CAAAA;AAC5B,SAAOJ,EAAMM,KAAMC,CAAAA,OAAMF,EAAeE,EAAAA,EAAGC,MAAM,IAAIZ,EAAAA,SAAAA,CAAAA;AAAc;AAUrE,SAASS,EAAeI,GAAAA;AACtB,SAAOA,EAAMC,QAAQ,UAAU,EAAA;AACjC;;;AC1CA,IAAM,aAAa,CAAC,UAClB,MAAM,QAAQ,+BAAO,MAAM;AAE7B,SAAS,iBACP,WACA,0BACA;AACA,QAAM,SAAqC,CAAC;AAC5C,SAAO,UAAU,UAAU;AACzB,UAAM,QAAQ,UAAU,CAAC;AACzB,UAAM,EAAE,MAAM,SAAS,KAAK,IAAI;AAChC,UAAM,QAAQ,KAAK,KAAK,GAAG;AAE3B,QAAI,CAAC,OAAO,KAAK,GAAG;AAClB,UAAI,iBAAiB,OAAO;AAC1B,cAAM,aAAa,MAAM,YAAY,CAAC,EAAE,OAAO,CAAC;AAEhD,eAAO,KAAK,IAAI;AAAA,UACd,SAAS,WAAW;AAAA,UACpB,MAAM,WAAW;AAAA,QACnB;AAAA,MACF,OAAO;AACL,eAAO,KAAK,IAAI,EAAE,SAAS,MAAM,KAAK;AAAA,MACxC;AAAA,IACF;AAEA,QAAI,iBAAiB,OAAO;AAC1B,YAAM,YAAY;AAAA,QAAQ,CAAC,eACzB,WAAW,OAAO,QAAQ,CAAC,MAAM,UAAU,KAAK,CAAC,CAAC;AAAA,MACpD;AAAA,IACF;AAEA,QAAI,0BAA0B;AAC5B,YAAM,QAAQ,OAAO,KAAK,EAAE;AAC5B,YAAM,WAAW,SAAS,MAAM,MAAM,IAAI;AAE1C,aAAO,KAAK,IAAI;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WACK,CAAC,EAAe,OAAO,UAAsB,MAAM,OAAO,IAC3D,MAAM;AAAA,MACZ;AAAA,IACF;AAEA,cAAU,MAAM;AAAA,EAClB;AAEA,SAAO;AACT;AAuCO,SAAS,YACd,QACA,eACA,kBAGI,CAAC,GACqC;AAC1C,SAAO,OAAO,QAAe,GAAG,YAAY;AAC1C,QAAI;AACF,YAAM,OAAO,MAAM,OACjB,gBAAgB,SAAS,SAAS,UAAU,YAC9C,EAAE,QAAQ,aAAa;AAEvB,cAAQ,6BAA6B,EAAuB,CAAC,GAAG,OAAO;AAEvE,aAAO;AAAA,QACL,QAAQ,CAAC;AAAA,QACT,QAAQ,gBAAgB,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,IAAI;AAAA,MAC5D;AAAA,IACF,SAAS,OAAO;AACd,UAAI,WAAW,KAAK,GAAG;AACrB,eAAO;AAAA,UACL,QAAQ,CAAC;AAAA,UACT,QAAQ;AAAA,YACN;AAAA,cACE,MAAM;AAAA,cACN,CAAC,QAAQ,6BACP,QAAQ,iBAAiB;AAAA,YAC7B;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AACF;",
  "names": ["setCustomValidity", "ref", "fieldPath", "errors", "error", "get", "message", "reportValidity", "validateFieldsNatively", "options", "fields", "field", "refs", "forEach", "toNestErrors", "shouldUseNativeValidation", "fieldErrors", "path", "Object", "assign", "isNameInFieldArray", "names", "keys", "fieldArrayErrors", "set", "name", "escapeBrackets", "some", "n", "match", "input", "replace"]
}
